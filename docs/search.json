[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "",
    "text": "Abstract. This research project aims to measure the effects of monetary policy shocks on stock price volatility using the Bayesian Structural Vector Autoregressive Model in the Australian economy from 1990 to 2023.\nKeywords. Bayesian Structural VARs, Monetary policy shocks, Stock price volatility, Impulse response function"
  },
  {
    "objectID": "index.html#diagnostic-tests",
    "href": "index.html#diagnostic-tests",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "2.1 Diagnostic Tests",
    "text": "2.1 Diagnostic Tests\n\n2.1.1 Autocorrelation/Partial autocorrelation Function Plots\nThe autocorrelation test is used to identify the presence of serial correlation between a variable’s current value and its lagged value, indicating that past values influence the current value.\nThe autocorrelation function (ACF) plots in Figure 3 shows that all the variables except for stock price volatility have non-zero autocorrelation for at least 20 lags, implying that only stock price volatility is a stationary series and the other variables are highly persistent.\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Plots of autocorrelation functions\n\n\nThe partial autocorrelation function (PACF) plots in Figure 4 shows that the partial autocorrelation for all the variables are significant at the first lag. The partial autocorrelation for exchange rates is also significant at 2.\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Plots of partial autocorrelation functions\n\n\n\n\n2.1.2 Unit Root Test\n\nAugmented Dickey-Fuller Test\nThe augmented Dickey-Fuller test of the null hypothesis of unit root nonstationarity was performed to test the presence of the unit root.\nTable 3 shows that the null hypothesis was not rejected at the 1% significance level for all the variables but not for stock price volatility, implying that all the variables except for stock price volatility are nonstationary series. However, stock price volatility is the log of bipower variation and took logarithmic scale twice,\n\n\n\n\n\nVariable\nTest statistic\nCritical value\nStationarity\n\n\n\n\nGDP\n-1.296\n-3.99\nNo\n\n\nInterest rates\n-2.991\n-3.46\nNo\n\n\nConsumer price index\n-2.845\n-3.99\nNo\n\n\nExchange rates\n-2.181\n-3.46\nNo\n\n\nStock prices\n-3.186\n-3.99\nNo\n\n\nStock price volatility\n-4.543\n-3.46\nYes\n\n\n\n\n\n\n\nTable 3: Augmented Dickey-Fuller test results\n\n\nTable 4 shows that the Augmented Dickey-Fuller test results on the first difference of the variables. We find that all the variables are unit root stationary at the 1% significance level, and conclude that all the variables are integrated of order one, \\(I(1)\\).\n\n\n\n\n\nVariable\nTest statistic\nCritical value\nStationarity\n\n\n\n\nGDP\n-5.258\n-3.46\nYes\n\n\nInterest rates\n-5.574\n-2.58\nYes\n\n\nConsumer price index\n-6.089\n-3.46\nYes\n\n\nExchange rates\n-7.589\n-2.58\nYes\n\n\nStock prices\n-6.905\n-3.46\nYes\n\n\nStock price volatility\n-8.322\n-2.58\nYes\n\n\n\n\n\n\n\nTable 4: Augmented Dickey-Fuller test results on the first difference"
  },
  {
    "objectID": "index.html#model-specification",
    "href": "index.html#model-specification",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "3.1 Model Specification",
    "text": "3.1 Model Specification\nThis study uses a Bayesian Structural vector autoregression (BSVAR) model to measure the dynamic and contemporaneous relationships between variables. The endogenous variables in the model are the following: \\[\nY_t=\n\\begin{pmatrix}\n   gdp_t\n\\\\ICR_t\n\\\\cpi_t\n\\\\EXR_t\n\\\\stp_t\n\\\\vol_t\n\\end{pmatrix}\n\\] \\(Y_t\\) contains six variables ordered as\n   (1) Real GDP, \\(gdp_t\\),\n   (2) Interest rates, \\(ICR_t\\),\n   (3) Consumer price index, \\(cpi_t\\),\n   (4) Exchange rates from AUD to USD, \\(EXR_t\\),\n   (5) Stock prices, \\(stp_t\\), and\n   (6) Stock price volatility, \\(vol_t\\).\n\nStructural Form\nThe Structural VAR model can be represented as follows: \\[\n\\begin{gather}\nB_0Y_t = b_0 + \\sum_{i=1}^{p} B_iY_{t-i} + u_t \\\\\nu_t|Y_{t-1} \\sim iid(0_N, I_N)\n\\end{gather}\n\\] where\n   \\(Y_t\\) is an \\(N \\times 1\\) vector of endogenous variables at time \\(t\\),\n   \\(B_0\\) is an \\(N \\times N\\) matrix capturing contemporaneous relationships between variables,\n   \\(u_t\\) is an \\(N \\times 1\\) vector conditionally on \\(Y_{t-1}\\) orthogonal structural shocks,\n   \\(N\\) is the number of endogeneous variables, and \\(p\\) is the lag length.\n\n\nReduced Form\nThrough the transformation, the corresponding Structural VAR model can be represented as the reduced form VAR model as follows: \\[\n\\begin{gather}\nY_t = \\mu_0 + \\sum_{i=1}^{p} A_iY_{t-i} + \\epsilon_t \\\\\n\\epsilon_t|Y_{t-1} \\sim iid(0_N, \\Sigma)\n\\end{gather}\n\\] where\n   \\(Y_t\\) is an \\(N \\times 1\\) vector of endogenous variables at time \\(t\\),\n   \\(A_i\\) is an \\(N \\times N\\) matrix of autoregressive slope parameters,\n   \\(\\mu_0\\) is an \\(N \\times 1\\) vector of constant terms,\n   \\(\\epsilon_t\\) is an \\(N \\times 1\\) vector of the white noise error terms,\n   \\(\\Sigma\\) is an \\(N \\times N\\) covariance matrix of error terms \\(\\epsilon_t\\), where \\(\\Sigma = B_0^{-1} {B_0^{-1}}'\\),\n   \\(N\\) is the number of endogeneous variables, and \\(p\\) is the lag length."
  },
  {
    "objectID": "index.html#bayes-theorem",
    "href": "index.html#bayes-theorem",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "3.2 Bayes’ theorem",
    "text": "3.2 Bayes’ theorem\nFor parameter estimation, the Bayes’ theorem is used to derive the joint posterior distribution.\nThe joint posterior distribution of \\(A\\) and \\(\\Sigma\\) can be estimated as follows: \\[\n\\begin{align}\n\\underbrace{p(A,\\Sigma|Y,X)}_{\\text{Posterior}} &\\propto L(A,\\Sigma|Y,X) \\cdot p(A,\\Sigma)\n\\\\ &\\propto \\underbrace{L(A,\\Sigma|Y,X)}_{\\text{Likelihood function}} \\cdot \\underbrace{p(A|\\Sigma) \\cdot p(\\Sigma)}_{\\text{Prior}}\n\\end{align}\n\\] ## 3.3 Minnesota Prior\nUsing Minnesota prior, we set the prior mean of \\(\\underline{A}\\) and \\(\\underline{V}\\) as the following:\n\\[\n\\begin{align}\n\\underline{A} = \\begin{bmatrix} \\mathbf{0}_{N \\times 1} \\\\ I_N \\\\ \\mathbf{0}_{N \\times (p-1)N} \\end{bmatrix}\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\underline{A} &= \\left[ \\mathbf{0}_{N \\times 1} \\quad I_N \\quad \\mathbf{0}_{N \\times (p-1)N} \\right]'\n\\\\ Var[vec(A)] &= \\Sigma \\otimes  \\underline{V}\n\\\\ \\underline{V} &= \\text{diag}([\\kappa_2 \\quad \\kappa_1 (\\mathbf{p}^{-2} \\otimes \\imath'_N)])\n\\\\ \\mathbf{p} &= [1,2, ..., p], \\qquad \\imath_N = [1,...,1]\n\\end{align}\n\\]\n   \\(\\kappa_1\\) is overall shrinkage level of autoregressive slopes, where common value is \\(0.02^2\\)\n   \\(\\kappa_2\\) is overall shrinkage of the constant term"
  },
  {
    "objectID": "index.html#standard-bayesian-svar-model",
    "href": "index.html#standard-bayesian-svar-model",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "4.1 Standard Bayesian SVAR Model",
    "text": "4.1 Standard Bayesian SVAR Model\n\n4.1.1 Model Specification\nThe reduced form can be represented in a matrix form as follows: \\[\n\\begin{gather}\nY = XA + E \\\\\n\\\\ E|X \\sim MN_{T \\times N}(0_{T \\times N},\\Sigma_{N \\times N},I_T) \\\\\n\\end{gather}\n\\] $$$$\n\\[\n\\begin{aligned}\nY = \\begin{bmatrix} y_{1}' \\\\y_{2}'  \\\\. \\\\. \\\\. \\\\y_{T}' \\end{bmatrix}_{T \\times N} \\quad\nA = \\begin{bmatrix}\\mu_{0}' \\\\A_{1}' \\\\.\\\\.\\\\.\\\\A_{p}' \\end{bmatrix}_{K \\times N} \\quad\nx_t =\\begin{bmatrix}\\ 1 \\\\y_{t-1} \\\\.\\\\.\\\\.\\\\y_{t-p} \\end{bmatrix}_{K \\times 1} \\quad\nX = \\begin{bmatrix}\\ x_{1}' \\\\x_{2}' \\\\.\\\\.\\\\.\\\\x_{T}' \\end{bmatrix}_{T \\times K} \\quad\nE = \\begin{bmatrix}\\ \\epsilon _{1}'  \\\\\\epsilon _{2}' \\\\.\\\\.\\\\.\\\\\\epsilon _{T}' \\end{bmatrix}_{T \\times N}\n\\end{aligned}\n\\]\nwhere\n   \\(Y\\) is a \\(T \\times N\\) matrix of endogenous variables,\n   \\(A\\) is a \\(K \\times N\\) matrix of autoregressive slope parameters,\n   \\(X\\) is a \\(T \\times N\\) matrix of covariates,\n   \\(E\\) is a \\(T \\times N\\) matrix of the white noise error terms,\n   \\(\\Sigma\\) is an \\(N \\times N\\) row-specific covariance matrix of error terms\n   \\(I_T\\) is an \\(T \\times T\\) identity matrix representing the column-specific covariance matrix of error, and\n   \\(N\\) is the number of endogeneous variables,\n   \\(T\\) is the number of time periods,\n   \\(p\\) is the lag length, and\n   \\(K = 1 + pN\\).\n\n\n4.1.2 Estimation Procedure\nFor estimation, the Bayes’ theorem is used to derive the joint posterior distribution for \\(A\\) and \\(\\Sigma\\). \\[\n\\begin{align}\n\\underbrace{p(A,\\Sigma|Y,X)}_{\\text{Posterior}} &\\propto L(A,\\Sigma|Y,X) \\cdot p(A,\\Sigma)\n\\\\ &\\propto \\underbrace{L(A,\\Sigma|Y,X)}_{\\text{Likelihood function}} \\cdot \\underbrace{p(A|\\Sigma) \\cdot p(\\Sigma)}_{\\text{Prior}}\n\\end{align}\n\\] This implies the following form for the kernel of the likelihood function: \\[\n\\begin{align}\nL(A,\\Sigma|Y,X) &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\exp \\left\\{-\\frac{1}{2} tr \\left[ \\Sigma^{-1}(Y-XA)'(Y-XA) \\right] \\right\\}\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T}{2}}\n\\\\ &\\times \\exp \\left\\{-\\frac{1}{2} tr \\left[\\Sigma^{-1}(A-\\hat{A})'X'X(A-\\hat{A}) \\right] \\right\\}\n\\\\ &\\times \\exp \\left\\{-\\frac{1}{2} tr \\left[\\Sigma^{-1}(Y-X \\hat{A})'(Y-X \\hat{A}) \\right] \\right\\}\n\\end{align}\n\\] where \\[\n\\begin{align}\n\\hat{A} &= (X'X)^{-1}X'Y\n\\\\ \\hat{\\Sigma} &= \\frac{1}{T} (Y-X \\hat{A})'(Y-X \\hat{A})\n\\end{align}\n\\] are from the maximum likelihood estimation.\nThe natural-conjugate prior distribution where \\(A\\) is matrix normal and \\(\\Sigma\\) follows inverse Wishart distribution has the same form as the joint posterior distribution for \\(A\\) and \\(\\Sigma\\). \\[\n\\begin{gather}\np(A,\\Sigma) = p(A|\\Sigma) \\cdot p(\\Sigma) \\\\\n\\\\ A|\\Sigma \\sim MN_{K \\times N}(\\underline{A},\\Sigma,\\underline{V}) \\\\\n\\\\ \\Sigma \\sim IW_N(\\underline{S},\\underline{\\nu})\n\\end{gather}\n\\] This implies the following form for the kernel of the natural-conjugate prior distribution: \\[\n\\begin{align}\np(A,\\Sigma) &= p(A|\\Sigma) \\cdot p(\\Sigma) \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{N+K+\\underline{v}+1}{2}}\n\\\\ &\\times \\exp \\left\\{-\\frac{1}{2}tr \\left[\\Sigma^{-1}(A-\\underline{A})'\\underline{V}^{-1}(A-\\underline{A}) \\right] \\right\\}\n\\\\ &\\times \\exp \\left\\{-\\frac{1}{2}tr \\left[\\Sigma^{-1}\\underline{S} \\right] \\right\\}\n\\end{align}\n\\]\nThe posterior distribution is given by the product of the likelihood and the priors. \\[\n\\begin{align}\np(A,\\Sigma|Y,X) &\\propto L(A,\\Sigma|Y,X) \\cdot p(A,\\Sigma) \\\\\n\\\\ &\\propto L(A,\\Sigma|Y,X) \\cdot p(A|\\Sigma) \\cdot p(\\Sigma) \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\exp \\left\\{-\\frac{1}{2} tr \\left[ \\Sigma^{-1}(A-\\hat{A})'X'X(A-\\hat{A}) \\right] \\right\\} \\cdot \\exp \\left\\{-\\frac{1}{2} tr \\left[\\Sigma^{-1}(Y-X \\hat{A})'(Y-X \\hat{A}) \\right] \\right\\}\n\\\\ &\\times \\det(\\Sigma)^{-\\frac{N+K+\\underline{v}+1}{2}} \\cdot \\exp\\left\\{-\\frac{1}{2}tr[\\Sigma^{-1}(A-\\underline{A})'\\underline{V}^{-1}(A-\\underline{A})] \\right\\} \\cdot \\exp\\left\\{-\\frac{1}{2}tr[\\Sigma^{-1}\\underline{S}] \\right\\} \\\\\n\\\\ &\\propto \\det{(\\Sigma)}^{-\\frac{T+N+K+\\underline{\\nu}+1}{2}}\n\\\\ &\\times \\exp \\left\\{-\\frac{1}{2} tr \\left[\\Sigma^{-1} \\left[(A-\\hat{A})'X'X(A-\\hat{A})+(A-\\underline{A})'\\underline{V}^{-1}(A-\\underline{A})+(Y-X\\hat{A})'(Y-X\\hat{A})+\\underline{S} \\right] \\right] \\right\\} \\\\\n\\\\ &\\propto \\det{(\\Sigma)}^{-\\frac{T+N+K+\\underline{\\nu}+1}{2}}\n\\\\ &\\times \\exp \\left\\{ -\\frac{1}{2} tr \\left[\\Sigma^{-1}\\left[(A-\\overline{A})'\\overline{V}^{-1} (A-\\overline{A})+\\underline{S}+Y'Y+\\underline{A}'\\underline{V}^{-1}\\underline{A}-\\overline{A}'\\overline{V}^{-1} \\overline{A} \\right] \\right] \\right\\}\n\\end{align}\n\\]\nCombining the terms and completing the squares for the terms within the square brackets yields the following the joint posterior distributions for \\(A\\) and \\(\\Sigma\\): \\[\n\\begin{gather}\np(A,\\Sigma|Y,X) = p(A|Y,X,\\Sigma) \\cdot p(\\Sigma|Y,X) = MNIW_{K \\times N}(\\overline{A}, \\overline{V}, \\overline{S}, \\overline{\\nu})\n\\\\\n\\\\ p(A|Y,X,\\Sigma) = MN_{K \\times N}(\\overline{A}, \\Sigma, \\overline{V}) \\\\\n\\\\ p(\\Sigma|Y,X) = IW_N(\\overline{S},\\overline{\\nu}) \\\\\n\\end{gather}\n\\]\nwhere the parameter of the joint posterior distribution are the following: \\[\n\\begin{align}\n\\overline{V} &= (X'X + \\underline{V}^{-1})^{-1}\n\\\\ \\overline{A} &= \\overline{V}(X'Y + \\underline{V}^{-1}\\underline{A})\n\\\\ \\overline{\\nu} &= T + \\underline{\\nu}\n\\\\ \\overline{S} &= \\underline{S} + Y'Y + \\underline{A}'\\underline{V}^{-1}\\underline{A} - \\overline{A}'\\overline{V}^{-1}\\overline{A}\n\\end{align}\n\\]\n\n\n4.1.3 Algorithm Validation\nTo check the validity of the algorithms, two independent bi-variate Gaussian random walk processes with 1,000 observations were generated to simulate unit-root non-stationary macroeconomic variables.\n\n\n\n\n\n\n\n\n\n\n\nSee R code\nRW.baseline &lt;- function(data, sign.restrictions, p, S){\n  \n  # Define the lag order and the number of iterations\n  ############################################################\n  # p                       # number of lags\n  # S                       # number of posterior draws\n  \n  # Create Y and X matrices\n  ############################################################\n  Y           &lt;- data[(p+1):nrow(data), ]\n  X           &lt;- matrix(1, nrow(Y), 1)\n  for (i in 1:p){\n    X         &lt;- cbind(X, data[(p+1):nrow(data)-i, ])\n    }\n\n  T           &lt;- nrow(Y)    # number of time periods\n  N           &lt;- ncol(Y)    # number of variables\n  K           &lt;- 1+p*N\n  \n  # Convert it into a matrix form\n  Y           &lt;- as.matrix(Y)\n  X           &lt;- as.matrix(X)\n  \n  # Calculate the MLE\n  ############################################################\n  A.hat       &lt;- solve(t(X)%*%X)%*%t(X)%*%Y                \n  Sigma.hat   &lt;- t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)  \n  \n  # Specify the prior distribution parameters\n  ############################################################\n  kappa.1     &lt;- 0.02^2\n  kappa.2     &lt;- 100\n  \n  A.prior     &lt;- matrix(0, nrow(A.hat), ncol(A.hat))\n  A.prior[2:(N+1),] &lt;- diag(N)\n  V.prior     &lt;- diag(c(kappa.2, kappa.1*((1:p)^(-2))%x%rep(1,N)))\n  S.prior     &lt;- diag(diag(Sigma.hat))\n  nu.prior    &lt;- N+1\n  \n  # Specify the matrix normal-inverse Wishart posterior parameters\n  ############################################################\n  V.bar.inv   &lt;- t(X)%*%X + diag(1/diag(V.prior))\n  V.bar       &lt;- solve(V.bar.inv)\n  A.bar       &lt;- V.bar%*%(t(X)%*%Y + diag(1/diag(V.prior))%*%A.prior)\n  nu.bar      &lt;- nrow(Y) + nu.prior\n  S.bar       &lt;- S.prior + t(Y)%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar\n  S.bar.inv   &lt;- solve(S.bar)\n  \n  # Draw Posterior distribution\n  ############################################################\n  ## Draw from the Reduced Form\n  ### Draw Sigma from the inverse Wishart distribution\n  Sigma.posterior   &lt;- rWishart(S, df=nu.bar, Sigma=S.bar.inv)\n  Sigma.posterior   &lt;- apply(Sigma.posterior, 3, solve)            \n  Sigma.posterior   &lt;- array(Sigma.posterior, c(N,N,S))\n  \n  ### Draw A from matrix-variate normal distribution\n  A.posterior       &lt;- array(rnorm(prod(c(dim(A.bar),S))),c(dim(A.bar),S)) \n  \n  # Initialise arrays to store posterior draws\n  B0.posterior      &lt;- array(NA, c(N,N,S))\n  B1.posterior      &lt;- array(NA, c(N,K,S))\n  \n  for (s in 1:S){\n    ## Draw from the Structural Form\n    ### Draw B0\n    cholSigma.s        &lt;- chol(Sigma.posterior[,,s])\n    L                  &lt;- t(chol(V.bar))\n    B0.posterior[,,s]  &lt;- solve(t(cholSigma.s)) \n    A.posterior[,,s]   &lt;- A.bar + L%*%A.posterior[,,s]%*%cholSigma.s\n    \n    ### Draw Bplus\n    B1.posterior[,,s]  &lt;- B0.posterior[,,s]%*%t(A.posterior[,,s])\n    }\n  \n  # Identification via sign restrictions\n  ############################################################\n  # Generate corresponding R matrix\n  R &lt;- diag(sign.restrictions)\n  \n  # Initialise arrays to store Q identified estimates\n  i.vec &lt;- c()\n  Q.store      &lt;- array(NA, c(N,N,S))\n  B0.store     &lt;- array(NA, c(N,N,S))\n  B1.store     &lt;- array(NA, c(N,K,S))\n  \n  for (s in 1:S){\n    B0.tilde      &lt;- B0.posterior[,,s]\n    B1.tilde      &lt;- B1.posterior[,,s]\n    \n    sign.restrictions.do.not.hold = TRUE\n    i=1\n    while (sign.restrictions.do.not.hold){\n      X           &lt;- matrix(rnorm(N*N), N, N)         \n      QR          &lt;- qr(X, tol=1e-10)\n      Q           &lt;- qr.Q(QR, complete=TRUE)\n      R           &lt;- qr.R(QR, complete=TRUE)\n      Q           &lt;- t(Q%*%diag(sign(diag(R))))\n      B0          &lt;- Q%*%B0.tilde                    \n      B1          &lt;- Q%*%B1.tilde                   \n      B0.inv      &lt;- solve(B0)      \n      check       &lt;- all(B0[1,1]&gt;0, B0[2,2]&gt;0)\n      \n      if (check){sign.restrictions.do.not.hold = FALSE}\n      i=i+1\n      }\n    \n    i.vec &lt;- c(i.vec, i) \n    Q.store[,,s]   &lt;- Q\n    B0.store[,,s]  &lt;- B0\n    B1.store[,,s]  &lt;- B1\n    }\n  \n  B0.mean     &lt;- apply(B0.store, 1:2, mean)  \n  B1.mean     &lt;- apply(B1.store, 1:2, mean)\n  \n  return(list(B0.mean = B0.mean, \n              B1.mean = B1.mean, \n              A.posterior = A.posterior, \n              Sigma.posterior = Sigma.posterior))\n  }\n\n\nThe results show that\n\n\n\nMean of the Matrix B[0]\n\n\n0.6396\n-0.0220\n\n\n0.0403\n0.6467\n\n\n\n\n\n\n\n\nMean of the Matrix B[+]\n\n\n0.0346\n0.6354\n-0.0212\n\n\n0.0156\n0.0446\n0.6433\n\n\n\n\n\n\n\n\nMean of the A posterior\n\n\n0.0537\n0.0189\n\n\n0.9940\n0.0072\n\n\n0.0009\n0.9947\n\n\n\n\n\n\n\n\nMean of the Sigma posterior\n\n\n0.9636\n-0.0117\n\n\n-0.0117\n0.9416"
  },
  {
    "objectID": "index.html#bayesian-svar-model-with-t-distributed-innovations",
    "href": "index.html#bayesian-svar-model-with-t-distributed-innovations",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "4.2 Bayesian SVAR Model with t-distributed Innovations",
    "text": "4.2 Bayesian SVAR Model with t-distributed Innovations\n\n4.2.1 Model Specification\nStock price volatility\n\\[\n\\begin{align}\nE_T &\\sim t_N(0, \\Sigma, \\nu)\n\\end{align}\n\\] Then, the reduced form can be represented in a matrix form as follows: \\[\n\\begin{gather}\nY = XA + E \\\\\n\\\\ E|X, \\lambda \\sim MN_{T \\times N}(0_{T \\times N},\\Sigma_{N \\times N},\\lambda I_T)\n\\end{gather}\n\\] where lambda is inverse gamma 2 distributed with shape and ..\n\\[\n\\lambda \\sim IG2(s_{\\lambda}, \\nu_{\\lambda})\n\\]\n\n\n4.2.2 Estimation Procedure\nUsing the Bayes’ theorem, the joint posterior distribution for \\(A\\) and \\(\\Sigma\\) is the following: \\[\n\\begin{align}\n\\underbrace{p(A,\\Sigma|Y,X)}_{\\text{Posterior}} &\\propto L(A,\\Sigma|Y,X) \\cdot p(A,\\Sigma)\n\\\\ &\\propto \\underbrace{L(A,\\Sigma|Y,X)}_{\\text{Likelihood function}} \\cdot \\underbrace{p(A|\\Sigma) \\cdot p(\\Sigma)}_{\\text{Prior}}\n\\end{align}\n\\]\nThe kernel of the likelihood function follows as: \\[\n\\begin{align}\nL(A,\\Sigma|Y,X,\\lambda) &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\det(\\lambda I_T)^{-\\frac{N}{2}} \\cdot \\exp \\left\\{-\\frac{1}{2} \\text{tr} \\left[\\Sigma^{-1}(Y-XA)'(\\lambda I_T)^{-1}(Y-XA) \\right] \\right\\}\n\\end{align}\n\\] The conditional posterior distribution of \\(A\\) and \\(\\Sigma\\): \\[\n\\begin{align}\np(A,\\Sigma|Y,X,\\lambda) &\\propto L(A,\\Sigma|Y,X,\\lambda) \\cdot p(A,\\Sigma) \\\\\n\\\\ &\\propto L(A,\\Sigma|Y,X,\\lambda) \\cdot p(A|\\Sigma,\\lambda) \\cdot p(\\Sigma|\\lambda) \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\det(\\lambda I_T)^{-\\frac{N}{2}} \\cdot \\exp \\left\\{-\\frac{1}{2} tr[\\Sigma^{-1} (Y-XA)' (\\lambda I_T)^{-1} (Y-XA) ] \\right\\}\n\\\\ &\\times\n\\det(\\Sigma)^{-\\frac{N+k+\\underline{\\nu}+1}{2}} \\cdot \\exp \\left\\{-\\frac{1}{2}tr[\\Sigma^{-1}(A-\\underline{A})'\\underline{V}^{-1}(A-\\underline{A})] \\right\\} \\cdot \\exp \\left\\{ -\\frac{1}{2}tr[\\Sigma^{-1}\\underline{S}] \\right\\} \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T+N+K+\\underline{\\nu}+1}{2}} \\cdot \\det(\\lambda I_T)^{-\\frac{N}{2}}\n\\\\ &\\times \\exp \\left\\{-\\frac{1}{2} tr[\\Sigma^{-1}(Y'(\\lambda I_T)^{-1}Y - 2A'X'(\\lambda I_T)^{-1}Y + A'X'(\\lambda I_T)^{-1}XA + A'\\underline{V}^{-1}A -2A'\\underline{V}^{-1}\\underline{A} + \\underline{A}'\\underline{V}^{-1}\\underline{A} + \\underline{S})] \\right\\}\n\\end{align}\n\\] This follows: \\[\n\\begin{gather}\np(A,\\Sigma|Y,X,\\lambda) = p(A|Y,X,\\Sigma, \\lambda) \\cdot p(\\Sigma|Y,X,\\lambda) = MNIW_{K \\times N}(\\overline{A}, \\overline{V}, \\overline{S}, \\overline{\\nu}) \\\\\n\\\\ p(A|Y,X,\\Sigma,\\lambda) = MN_{K \\times N}(\\overline{A}, \\Sigma, \\overline{V}) \\\\\n\\\\ p(\\Sigma|Y,X,\\lambda) = IW_N(\\overline{S},\\overline{\\nu}) \\\\\n\\end{gather}\n\\] where \\[\n\\begin{align}\n\\overline{V} &= [X'(\\lambda I_T)^{-1}X + \\underline{V}^{-1}]^{-1} \\\\\n\\overline{A} &= \\overline{V}[X'(\\lambda I_T)^{-1}Y + \\underline{V}^{-1}\\underline{A}] \\\\\n\\overline{S} &= Y'(\\lambda I_T)^{-1}Y + \\underline{A}'\\underline{V}^{-1}\\underline{A} - \\overline{A}'\\overline{V}^{-1}\\overline{A} + \\underline{S} \\\\\n\\overline{\\nu} &= \\underline{\\nu} + T\n\\end{align}\n\\]\nThe conditional posterior distribution of \\(\\lambda\\): \\[\n\\begin{align}\np(\\lambda|Y,X,A,\\Sigma) &\\propto L(A,\\Sigma,\\lambda|Y,X) \\cdot p(A,\\Sigma) \\cdot p(\\lambda) \\\\\n\\\\ &\\propto L(A,\\Sigma,\\lambda|Y,X) \\cdot p(\\lambda) \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\det(\\lambda I_T)^{-\\frac{N}{2}} \\cdot\n\\exp \\left\\{-\\frac{1}{2} tr[\\Sigma^{-1} (Y-XA)' (\\lambda I_T)^{-1} (Y-XA)] \\right\\}\n\\\\ &\\times \\lambda^{-\\frac{\\underline{\\nu_{\\lambda}}+2}{2}} \\cdot\n\\exp \\left\\{-\\frac{1}{2}\\frac{\\underline{s_{\\lambda}}}{\\lambda} \\right\\} \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\det(I_T)^{-\\frac{N}{2}} \\cdot\n\\exp \\left\\{-\\frac{1}{2}\\frac{1}{\\lambda} tr[\\Sigma^{-1}(Y-XA)'(Y-XA)] \\right\\} \\\\\n&\\times \\lambda^{-\\frac{TN}{2}} \\cdot \\lambda^{-\\frac{\\underline{\\nu_{\\lambda}}+2}{2}} \\cdot\n\\exp \\left\\{-\\frac{1}{2}\\frac{\\underline{s_{\\lambda}}}{\\lambda} \\right\\} \\\\\n\\\\ &\\propto \\det(\\Sigma)^{-\\frac{T}{2}} \\cdot \\det(I_T)^{-\\frac{N}{2}} \\cdot \\lambda^{-\\frac{TN+\\underline{\\nu_{\\lambda}}+2}{2}} \\cdot \\exp \\left\\{-\\frac{1}{2}\\frac{1}{\\lambda} [tr(\\Sigma^{-1}(Y-XA)'(Y-XA)) + \\underline{s_{\\lambda}}] \\right\\}\n\\end{align}\n\\] This follows \\[\n\\begin{align}\n\\lambda|Y,X, A,\\Sigma &\\sim IG2(\\overline{s_{\\lambda}},\\overline{\\nu_{\\lambda}})\n\\end{align}\n\\] where \\[\n\\begin{align}\n\\overline{s_{\\lambda}} &= tr[\\Sigma^{-1}(Y-XA)'(Y-XA)] + \\underline{s_{\\lambda}} \\\\\n\\overline{\\nu_{\\lambda}} &= \\underline{\\nu_{\\lambda}} + TN\n\\end{align}\n\\]\n\n\n4.2.3 Algorithm Validation\nTo check the validity of the algorithms, two independent bi-variate Gaussian random walk processes with 1,000 observations were generated to simulate unit-root non-stationary macroeconomic variables.\n\nGibbs Sampler\nInitialise \\(\\lambda\\) at \\(\\lambda^{(0)}\\) From S = 1,\n\nDraw \\(\\Sigma^{(s)} \\sim P(\\Sigma|Y,X,\\lambda^{(s-1)})\\) from the \\(IW_N(\\overline{S},\\overline{\\nu})\\) distribution\nDraw \\(A^{(s)} \\sim P(A|Y,X,\\Sigma^{(s)},\\lambda^{(s-1)})\\) from the \\(MN_{K \\times N}(\\overline{A},\\Sigma^{(s)}, \\overline{V})\\) distribution\nDraw \\(\\lambda^{(s)} \\sim P(\\lambda|Y,X,A^{(s)},\\Sigma^{(s)})\\) from \\(IG2(\\overline{s_{\\lambda}},\\overline{\\nu_{\\lambda}})\\) distribution\n\n\n\nSee R code\nRW.extended &lt;- function(data, sign.restrictions, p, S){\n   \n  # Define the lag order and the number of iterations\n  ############################################################\n  # p                       # number of lags\n  # S                       # number of posterior draws\n\n  # Create Y and X matrices\n  ############################################################\n  Y           &lt;- data[(p+1):nrow(data), ]\n  X           &lt;- matrix(1, nrow(Y), 1)\n  for (i in 1:p){\n    X         &lt;- cbind(X, data[(p+1):nrow(data)-i, ])\n    }\n  \n  T           &lt;- nrow(Y)    # number of time periods\n  N           &lt;- ncol(Y)    # number of variables\n  K           &lt;- 1+p*N\n  \n  # Convert it into a matrix form\n  Y           &lt;- as.matrix(Y)\n  X           &lt;- as.matrix(X)\n  \n  # Calculate the MLE\n  ############################################################\n  A.hat       &lt;- solve(t(X)%*%X)%*%t(X)%*%Y                \n  Sigma.hat   &lt;- t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)\n  \n  # Specify prior distribution parameters\n  ############################################################\n  kappa.1     &lt;- 0.02^2\n  kappa.2     &lt;- 100\n  \n  A.prior           &lt;- matrix(0, nrow(A.hat), ncol(A.hat))\n  A.prior[2:(N+1),] &lt;- diag(N)\n  V.prior           &lt;- diag(c(kappa.2, kappa.1*((1:p)^(-2))%x%rep(1,N)))\n  S.prior           &lt;- diag(diag(Sigma.hat))\n  nu.prior          &lt;- N+1\n  s.prior.lambda    &lt;- 5   # assume that it is fixed\n  nu.prior.lambda   &lt;- 5   # assume that it is fixed\n  lambda            &lt;- s.prior.lambda/rchisq(1, nu.prior.lambda)\n  \n  # Initialise arrays to store posterior draws\n  Sigma.posterior   &lt;- array(NA, c(N,N,S))\n  A.posterior       &lt;- array(NA, c(K,N,S))\n  lambda.posterior  &lt;- rep(NA, S)\n  B0.posterior      &lt;- array(NA, c(N,N,S))\n  B1.posterior      &lt;- array(NA, c(N,K,S))\n  \n  for (s in 1:S){\n    \n    # Specify the matrix normal-inverse Wishart posterior parameters\n    ############################################################\n    V.bar.inv  &lt;- t(X)%*%X/lambda + diag(1/diag(V.prior))\n    V.bar      &lt;- solve(V.bar.inv)\n    A.bar      &lt;- V.bar%*%(t(X)%*%Y/lambda + diag(1/diag(V.prior))%*%A.prior)\n    nu.bar     &lt;- nrow(Y) + nu.prior\n    S.bar      &lt;- S.prior + t(Y)%*%Y/lambda + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar\n    S.bar.inv  &lt;- solve(S.bar)\n    \n    # Draw Posterior distribution\n    ############################################################\n    ## Draw from the Reduced Form\n    ### Draw Sigma from the inverse Wishart distribution\n    Sigma.posterior.inv   &lt;- rWishart(1, df=nu.bar, Sigma=S.bar.inv)[,,1]\n    Sigma.posterior[,,s]  &lt;- solve(Sigma.posterior.inv)\n    \n    ### Draw A from matrix-variate normal distribution\n    A.posterior[,,s]      &lt;- matrix(mvtnorm::rmvnorm(1, mean=as.vector(A.bar), sigma=Sigma.posterior[,,s]%x%V.bar), ncol=N)\n    \n    ### Draw lambda from inverse gamma 2 distribution\n    s.posterior.lambda    &lt;- sum(diag(Sigma.posterior.inv%*%t(Y-X%*%A.posterior[,,s])%*%(Y-X%*%A.posterior[,,s]))) + s.prior.lambda\n    nu.posterior.lambda   &lt;- nrow(Y)*N + nu.prior.lambda\n    lambda                &lt;- s.posterior.lambda/rchisq(1, nu.posterior.lambda)\n    lambda.posterior[s]   &lt;- lambda\n  \n    ## Draw from the Structural Form\n    ### Draw B0\n    cholSigma.s           &lt;- chol(Sigma.posterior[,,s])\n    B0.posterior[,,s]     &lt;- solve(t(cholSigma.s)) \n    \n    ### Draw Bplus\n    B1.posterior[,,s]     &lt;- B0.posterior[,,s]%*%t(A.posterior[,,s])\n    }\n  \n  # Identification via sign restrictions \n  ############################################################\n  # Generate corresponding R matrix\n  R &lt;- diag(sign.restrictions)\n  \n  # Initialise arrays to store Q identified estimates\n  i.vec &lt;- c()\n  Q.store      &lt;- array(NA, c(N,N,S))\n  B0.store     &lt;- array(NA, c(N,N,S))\n  B1.store     &lt;- array(NA, c(N,K,S))\n  \n  for (s in 1:S){\n    B0.tilde      &lt;- B0.posterior[,,s]\n    B1.tilde      &lt;- B1.posterior[,,s]\n    \n    sign.restrictions.do.not.hold = TRUE\n    i=1\n    while (sign.restrictions.do.not.hold){\n      X           &lt;- matrix(rnorm(N*N), N, N)         \n      QR          &lt;- qr(X, tol=1e-10)\n      Q           &lt;- qr.Q(QR, complete=TRUE)\n      R           &lt;- qr.R(QR, complete=TRUE)\n      Q           &lt;- t(Q%*%diag(sign(diag(R))))\n      B0          &lt;- Q%*%B0.tilde                    \n      B1          &lt;- Q%*%B1.tilde                   \n      B0.inv      &lt;- solve(B0)      \n      check       &lt;- all(B0[1,1]&gt;0, B0[2,2]&gt;0)\n      \n      if (check){sign.restrictions.do.not.hold = FALSE}\n      i=i+1\n      }\n    \n    i.vec &lt;- c(i.vec, i) \n    Q.store[,,s]   &lt;- Q\n    B0.store[,,s]  &lt;- B0\n    B1.store[,,s]  &lt;- B1\n    }\n  \n  B0.mean     &lt;- apply(B0.store, 1:2, mean)  \n  B1.mean     &lt;- apply(B1.store, 1:2, mean)\n  \n  return(list(B0.mean = B0.mean, \n              B1.mean = B1.mean, \n              A.posterior = A.posterior, \n              Sigma.posterior = Sigma.posterior,\n              lambda.posterior = lambda.posterior))\n  }\n\n\nThe results shows that\n\n\n\nMean of the Matrix B[0]\n\n\n0.8765\n0.0104\n\n\n0.0103\n0.8870\n\n\n\n\n\n\n\n\nMean of the Matrix B[+]\n\n\n0.0440\n0.8717\n0.0111\n\n\n0.0184\n0.0162\n0.8827\n\n\n\n\n\n\n\n\nMean of the A posterior\n\n\n0.0496\n0.0179\n\n\n0.9945\n0.0068\n\n\n0.0008\n0.9950\n\n\n\n\n\n\n\n\nMean of the Sigma posterior\n\n\n0.5926\n-0.0067\n\n\n-0.0067\n0.5793\n\n\n\n\n\n\n\n\nMean of the lambda\n\n\nlambda\n\n\n\n\n1.8592"
  },
  {
    "objectID": "index.html#bayesian-svar-model-with-common-stochastic-volatility",
    "href": "index.html#bayesian-svar-model-with-common-stochastic-volatility",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "4.3 Bayesian SVAR Model with Common Stochastic Volatility",
    "text": "4.3 Bayesian SVAR Model with Common Stochastic Volatility\n\n4.3.1 Model Specification\n\n\n4.3.2 Estimation Procedure\n\n\n4.3.3 Algorithm Validation"
  },
  {
    "objectID": "index.html#standard-bayesian-svar-model-1",
    "href": "index.html#standard-bayesian-svar-model-1",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "5.1 Standard Bayesian SVAR model",
    "text": "5.1 Standard Bayesian SVAR model\n\\[\nf(B_0,B_+)=\\Theta_0=B=\n\\begin{bmatrix}\n* & - & * & * & * & * \\\\\n* & + & * & * & * & * \\\\\n* & - & * & * & * & * \\\\\n* & + & * & * & * & * \\\\\n* & * & * & * & * & * \\\\\n* & * & * & * & * & * \\\\\n\\end{bmatrix}\n\\]\n\\[\n\\textbf{R}=\\begin{bmatrix}\n-1 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & -1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\end{bmatrix}\n\\]\n1990 Q2 onwards..\n\n\n\nMean of the Matrix B[0]\n\n\n0.0694\n0.0020\n-0.6716\n-0.0681\n-0.0247\n-0.0054\n\n\n-34.1442\n1.1094\n-69.4560\n9.0566\n0.0156\n-0.0059\n\n\n-0.2358\n0.0047\n-0.0953\n-0.0121\n-0.0282\n-0.0023\n\n\n-0.0503\n0.0064\n0.0161\n0.0186\n-0.0521\n0.0040\n\n\n0.1885\n0.0032\n0.3990\n-0.0788\n-0.0052\n-0.0030\n\n\n-0.0946\n-0.0067\n0.2425\n0.0103\n-0.0054\n0.0047\n\n\n\n\n\n\n\n\nMean of the Matrix B[+]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0114\n0.0736\n0.0018\n-0.6650\n-0.0668\n-0.0275\n-0.0022\n0.0007\n0.0007\n0.0012\n0.0040\n-0.0020\n-0.0015\n-0.0003\n-0.0001\n-0.0045\n0.0028\n-0.0012\n-0.0005\n-0.0005\n-5e-04\n-0.0017\n-0.0017\n0.0004\n0.0002\n\n\n-0.2452\n-33.8944\n1.4198\n-69.4502\n9.0993\n0.0086\n0.0818\n0.0357\n-0.4225\n-0.0037\n-0.1873\n-0.1318\n0.0004\n-0.0002\n-0.0089\n-0.0039\n-0.1145\n-0.0506\n-0.0693\n-0.0020\n7e-02\n-0.0018\n-0.0550\n-0.0308\n-0.0365\n\n\n-0.0040\n-0.2355\n0.0058\n-0.0933\n-0.0077\n-0.0316\n0.0000\n0.0006\n0.0006\n0.0010\n-0.0018\n0.0014\n-0.0008\n0.0018\n-0.0016\n0.0024\n0.0005\n-0.0032\n-0.0003\n0.0011\n-2e-04\n0.0009\n0.0012\n-0.0008\n-0.0005\n\n\n-0.0265\n-0.0540\n0.0073\n0.0177\n0.0208\n-0.0452\n0.0024\n-0.0023\n-0.0009\n-0.0033\n0.0025\n0.0005\n-0.0002\n-0.0006\n0.0005\n-0.0024\n-0.0017\n0.0017\n0.0002\n0.0003\n-7e-04\n-0.0009\n-0.0001\n0.0000\n0.0000\n\n\n0.0338\n0.1810\n0.0057\n0.4033\n-0.0772\n-0.0048\n-0.0033\n-0.0019\n-0.0009\n0.0002\n-0.0006\n0.0021\n0.0009\n0.0011\n-0.0018\n0.0001\n0.0021\n-0.0005\n-0.0005\n-0.0014\n-4e-04\n0.0000\n0.0014\n-0.0012\n-0.0003\n\n\n-0.0333\n-0.0961\n-0.0103\n0.2402\n0.0101\n-0.0009\n0.0035\n-0.0017\n0.0050\n0.0048\n0.0004\n0.0013\n0.0007\n0.0011\n-0.0017\n-0.0009\n-0.0004\n-0.0011\n0.0007\n-0.0012\n1e-03\n0.0000\n0.0008\n0.0003\n-0.0006\n\n\n\n\n\nImpulse response functions of the baseline model show a positive monetary policy shock on variables. The shaded area represents 68% of the confidence interval. In the short run, GDP decreases gradually, but a year after the shock, GDP decreases at a steeper rate. In the short run, interest rates immediately respond to the shock and normalised after five years of the shock. The consumer price index slightly decreases in the short run. The exchange rate has a positive effect in the short and long run. The stock price has a positive effect in the short run, but it does not have a positive effect in the long run.\n\n\nSee R code\n# Define the lag order and the number of iterations\n############################################################\np           &lt;- 4          # number of lags (data frequency (quarter))\nS           &lt;- 50000      # number of posterior draws\nh           &lt;- 20         # forecast horizon\n\n# Create Y and X matrices\n############################################################\nY           &lt;- variables[(p+1):nrow(variables), ]\nX           &lt;- matrix(1, nrow(Y), 1)\nfor (i in 1:p){\n  X         &lt;- cbind(X, variables[(p+1):nrow(variables)-i, ])\n  }\n\nT           &lt;- nrow(Y)    # number of time periods\nN           &lt;- ncol(Y)    # number of variables\nK           &lt;- 1+p*N\n\n# Convert it into a matrix form\nY           &lt;- as.matrix(Y)\nX           &lt;- as.matrix(X)\n\n# Calculate the MLE\n############################################################\nA.hat       &lt;- solve(t(X)%*%X)%*%t(X)%*%Y                \nSigma.hat   &lt;- t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)  \n  \n# Specify the prior distribution parameters\n############################################################\nkappa.1     &lt;- 1\nkappa.2     &lt;- 100\n  \nA.prior     &lt;- matrix(0, nrow(A.hat), ncol(A.hat))\nA.prior[2:(N+1),] &lt;- diag(N)\nV.prior     &lt;- diag(c(kappa.2, kappa.1*((1:p)^(-2))%x%rep(1,N)))\nS.prior     &lt;- diag(diag(Sigma.hat))\nnu.prior    &lt;- N+1\n  \n# Specify the matrix normal-inverse Wishart posterior parameters\n############################################################\nV.bar.inv   &lt;- t(X)%*%X + diag(1/diag(V.prior))\nV.bar       &lt;- solve(V.bar.inv)\nA.bar       &lt;- V.bar%*%(t(X)%*%Y + diag(1/diag(V.prior))%*%A.prior)\nnu.bar      &lt;- nrow(Y) + nu.prior\nS.bar       &lt;- S.prior + t(Y)%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar\nS.bar.inv   &lt;- solve(S.bar)\n  \n# Draw Posterior distribution\n############################################################\n## Draw from the Reduced Form\n### Draw Sigma from the inverse Wishart distribution\nSigma.posterior   &lt;- rWishart(S, df=nu.bar, Sigma=S.bar.inv)\nSigma.posterior   &lt;- apply(Sigma.posterior, 3, solve)            \nSigma.posterior   &lt;- array(Sigma.posterior, c(N,N,S))\n\n### Draw A from matrix-variate normal distribution\nA.posterior       &lt;- array(rnorm(prod(c(dim(A.bar),S))),c(dim(A.bar),S)) \n  \n# Initialise arrays to store posterior draws\nB0.posterior      &lt;- array(NA, c(N,N,S))\nB1.posterior      &lt;- array(NA, c(N,K,S))\n  \nfor (s in 1:S){\n  ## Draw from the Structural Form\n  ### Draw B0\n  cholSigma.s        &lt;- chol(Sigma.posterior[,,s])\n  L                  &lt;- t(chol(V.bar))\n  B0.posterior[,,s]  &lt;- solve(t(cholSigma.s)) \n  A.posterior[,,s]   &lt;- A.bar + L%*%A.posterior[,,s]%*%cholSigma.s\n  \n  ### Draw Bplus\n  B1.posterior[,,s]  &lt;- B0.posterior[,,s]%*%t(A.posterior[,,s])\n  }\n  \n# Identification via sign restrictions\n############################################################\n# Generate corresponding R matrix\nsign.restrictions &lt;- c(-1, 1, -1, 1, 0, 0)\nR &lt;- diag(sign.restrictions)\n  \n# Initialise arrays to store Q identified estimates\ni.vec &lt;- c()\nQ.store      &lt;- array(NA, c(N,N,S))\nB0.store     &lt;- array(NA, c(N,N,S))\nB1.store     &lt;- array(NA, c(N,K,S))\n\nfor (s in 1:S){\n  B0.tilde      &lt;- B0.posterior[,,s]\n  B1.tilde      &lt;- B1.posterior[,,s]\n    \n  sign.restrictions.do.not.hold = TRUE\n  i=1\n  while (sign.restrictions.do.not.hold){\n    X           &lt;- matrix(rnorm(N*N), N, N)         \n    QR          &lt;- qr(X, tol=1e-10)\n    Q           &lt;- qr.Q(QR, complete=TRUE)\n    R           &lt;- qr.R(QR, complete=TRUE)\n    Q           &lt;- t(Q%*%diag(sign(diag(R))))\n    B0          &lt;- Q%*%B0.tilde                    \n    B1          &lt;- Q%*%B1.tilde                   \n    B0.inv      &lt;- solve(B0)      \n    check       &lt;- all(B0.inv[1,2]&lt;0, B0.inv[2,2]&gt;0, B0.inv[3,2]&lt;0, B0.inv[4,2]&gt;0)\n    \n    if (check){sign.restrictions.do.not.hold = FALSE}\n    i=i+1\n    }\n  \n  i.vec &lt;- c(i.vec, i) \n  Q.store[,,s]   &lt;- Q\n  B0.store[,,s]  &lt;- B0\n  B1.store[,,s]  &lt;- B1\n  }\n\n# Impulse response functions\n############################################################\n# Transform B0 matrices to B\n# Initialise arrays to store posterior draws\nB.posterior &lt;- array(NA, c(N,N,S))\n  \nfor (s in 1:S){\n  B.posterior[,,s]  &lt;- solve(B0.store[,,s])\n  }\n\n# Initialise arrays to store posterior draws\nIRF.posterior       &lt;- array(NA, c(N,N,h+1,S))\nIRF.inf.posterior   &lt;- array(NA, c(N,N,S))\nJ                   &lt;- cbind(diag(N), matrix(0,N,N*(p-1)))\n  \nfor (s in 1:S){\n  # Define A matrix in VAR(1) representation\n  A.bold                     &lt;- rbind(t(A.posterior[2:(1+N*p),,s]), cbind(diag(N*(p-1)), matrix(0,N*(p-1),N)))\n  IRF.inf.posterior[,,s]     &lt;- J%*%solve(diag(N*p)-A.bold)%*%t(J)%*%B.posterior[,,s]\n  A.bold.power               &lt;- A.bold\n  \n  for (i in 1:(h+1)){\n    if (i==1){\n      IRF.posterior[,,i,s]      &lt;- B.posterior[,,s]\n      } else {\n        IRF.posterior[,,i,s]    &lt;- J%*%A.bold.power%*%t(J)%*%B.posterior[,,s]\n        A.bold.power            &lt;- A.bold.power%*%A.bold\n      }\n    }\n  }\n\nlibrary(HDInterval)\n\n# Impulse response functions plots\n############################################################\nIRF.posterior.mps   &lt;- IRF.posterior[,2,,]\nIRFs.k1             &lt;- apply(IRF.posterior.mps,1:2,median)\nIRFs.inf.k1         &lt;- apply(IRF.posterior.mps,1,mean)\nrownames(IRFs.k1)   &lt;- colnames(variables)\n\nIRFs.k1.hdi    &lt;- apply(IRF.posterior.mps, 1:2, hdi, credMass=0.68)\nhh             &lt;- 1:(h+1)\n\npar(mfrow=c(3, 2), mar=c(3, 3, 2, 2), cex.axis=1.5, cex.lab=1.5)\nfor (n in 1:N){\n  ylims=range(IRFs.k1[n,hh], IRFs.k1.hdi[,n,1:(h+1)], 0)\n  plot(hh,IRFs.k1[n,hh], type=\"l\", ylim=ylims, axes=FALSE, xlab=\"\", main=rownames(IRFs.k1)[n])\n  if (n==5){\n    axis(1, c(1,5,9,13,17,21), c(\"0\",\"1yr\",\"2yr\",\"3yr\",\"4yr\",\"5yr\"))\n    } else {\n      axis(1, c(1,5,9,13,17,21), c(\"0\",\"1yr\",\"2yr\",\"3yr\",\"4yr\",\"5yr\"))\n      }\n  axis(2, c(ylims[1], 0, ylims[2]), round(c(ylims[1], 0, ylims[2]), 3))\n  polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh], IRFs.k1.hdi[2,n,(h+1):1]), col=mcxs1.shade1, border=mcxs1.shade1)\n  abline(h=0)\n  lines(hh, IRFs.k1[n,hh], lwd=2, col=\"darkblue\")\n  }"
  },
  {
    "objectID": "index.html#bayesian-svar-model-with-t-distributed-innovations-1",
    "href": "index.html#bayesian-svar-model-with-t-distributed-innovations-1",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "5.2 Bayesian SVAR Model with t-distributed Innovations",
    "text": "5.2 Bayesian SVAR Model with t-distributed Innovations\n\n\n\nMean of the Matrix B[0]\n\n\n-83.2127\n-0.0314\n37.5429\n1.6474\n1.1030\n0.0230\n\n\n0.3723\n2.5987\n-41.0519\n-9.2667\n0.7129\n-0.1650\n\n\n19.2241\n0.7167\n-155.9094\n-0.8422\n1.5676\n-0.0333\n\n\n-5.8935\n-0.9006\n4.8326\n26.8952\n-6.2696\n0.2251\n\n\n-0.0757\n-0.0045\n2.1177\n-0.1662\n-0.0471\n-0.0001\n\n\n-0.0318\n0.0035\n-0.1938\n0.0558\n-0.0651\n-0.0066\n\n\n\n\n\n\n\n\nMean of the Matrix B[+]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-2.9551\n-82.9891\n0.1261\n37.7028\n1.5815\n1.1214\n0.2783\n0.0476\n-0.1089\n0.0350\n-0.0346\n-0.0055\n-0.1086\n0.0202\n-0.0187\n0.0146\n-0.0122\n-0.0031\n-0.0607\n0.0079\n0.0219\n0.0072\n-0.0006\n0.0032\n-0.0088\n\n\n2.7941\n0.1902\n3.2088\n-41.2557\n-9.1792\n0.7312\n-0.2391\n-0.0529\n-0.4764\n-0.0563\n-0.0172\n-0.0128\n0.0523\n-0.0224\n-0.2173\n-0.0241\n-0.0194\n-0.0187\n-0.0704\n-0.0158\n-0.0864\n-0.0141\n-0.0131\n-0.0156\n-0.0653\n\n\n1.1103\n19.1631\n0.4750\n-155.9656\n-0.6819\n1.4184\n-0.1043\n-0.0142\n0.0741\n-0.0050\n0.0330\n-0.0472\n-0.0490\n-0.0082\n0.0549\n-0.0059\n0.0096\n-0.0188\n-0.0044\n-0.0062\n0.0400\n-0.0010\n0.0022\n-0.0165\n-0.0530\n\n\n-0.8485\n-5.8465\n-1.1557\n4.8590\n26.6870\n-6.1669\n0.2590\n0.0082\n0.1760\n0.0130\n-0.0849\n0.0178\n0.0483\n0.0069\n0.1019\n0.0074\n-0.0361\n0.0160\n0.0658\n0.0057\n0.0435\n0.0027\n-0.0218\n0.0145\n0.0786\n\n\n-0.0192\n-0.0800\n-0.0006\n2.1161\n-0.1687\n-0.0427\n0.0018\n0.0037\n-0.0014\n-0.0004\n-0.0010\n-0.0002\n-0.0012\n0.0008\n-0.0003\n-0.0001\n-0.0009\n0.0010\n-0.0014\n0.0014\n-0.0015\n-0.0032\n-0.0001\n0.0009\n0.0012\n\n\n0.0471\n-0.0286\n0.0016\n-0.1965\n0.0422\n-0.0688\n-0.0027\n0.0002\n0.0009\n-0.0012\n0.0050\n0.0014\n-0.0010\n-0.0004\n0.0001\n0.0002\n-0.0021\n0.0005\n-0.0003\n-0.0030\n-0.0001\n0.0003\n-0.0012\n0.0012\n0.0001\n\n\n\n\n\nImpulse response functions of the t-distributed innovation model show a positive monetary policy shock on variables. In the short run, interest rates immediately respond to the shock and normalised around five years after the shock. The consumer price index slightly decreases in the short run. There are no significant effects on GDP, stock prices, or stock price volatility. Consumer price index and exchange rates decrease slightly, but they are also not significant.\n\n\nSee R code\n# Define the lag order and the number of iterations\n############################################################\np           &lt;- 4          # number of lags (data frequency (quarter))\nS           &lt;- 50000      # number of posterior draws\nh           &lt;- 20         # forecast horizon\n\n# Create Y and X matrices\n############################################################\nY           &lt;- variables[(p+1):nrow(variables), ]\nX           &lt;- matrix(1, nrow(Y), 1)\nfor (i in 1:p){\n  X         &lt;- cbind(X, variables[(p+1):nrow(variables)-i, ])\n  }\n\nT           &lt;- nrow(Y)    # number of time periods\nN           &lt;- ncol(Y)    # number of variables\nK           &lt;- 1+p*N\n\n# Convert it into a matrix form\nY           &lt;- as.matrix(Y)\nX           &lt;- as.matrix(X)\n\n# Calculate the MLE\n############################################################\nA.hat       &lt;- solve(t(X)%*%X)%*%t(X)%*%Y                \nSigma.hat   &lt;- t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)\n\n# Specify prior distribution parameters\n############################################################\nkappa.1     &lt;- 1\nkappa.2     &lt;- 100\n\nA.prior           &lt;- matrix(0, nrow(A.hat), ncol(A.hat))\nA.prior[2:(N+1),] &lt;- diag(N)\nV.prior           &lt;- diag(c(kappa.2, kappa.1*((1:p)^(-2))%x%rep(1,N)))\nS.prior           &lt;- diag(diag(Sigma.hat))\nnu.prior          &lt;- N+1\ns.prior.lambda    &lt;- 5   # assume that it is fixed\nnu.prior.lambda   &lt;- 5   # assume that it is fixed\nlambda            &lt;- s.prior.lambda/rchisq(1, nu.prior.lambda)\n\n# Initialise arrays to store posterior draws\nSigma.posterior   &lt;- array(NA, c(N,N,S))\nA.posterior       &lt;- array(NA, c(K,N,S))\nlambda.posterior  &lt;- rep(NA, S)\nB0.posterior      &lt;- array(NA, c(N,N,S))\nB1.posterior      &lt;- array(NA, c(N,K,S))\n\nfor (s in 1:S){\n  \n  # Specify the matrix normal-inverse Wishart posterior parameters\n  ############################################################\n  V.bar.inv  &lt;- t(X)%*%X/lambda + diag(1/diag(V.prior))\n  V.bar      &lt;- solve(V.bar.inv)\n  A.bar      &lt;- V.bar%*%(t(X)%*%Y/lambda + diag(1/diag(V.prior))%*%A.prior)\n  nu.bar     &lt;- nrow(Y) + nu.prior\n  S.bar      &lt;- S.prior + t(Y)%*%Y/lambda + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar\n  S.bar.inv  &lt;- solve(S.bar)\n  \n  # Draw Posterior distribution\n  ############################################################\n  ## Draw from the Reduced Form\n  ### Draw Sigma from the inverse Wishart distribution\n  Sigma.posterior.inv   &lt;- rWishart(1, df=nu.bar, Sigma=S.bar.inv)[,,1]\n  Sigma.posterior[,,s]  &lt;- solve(Sigma.posterior.inv)\n  \n  ### Draw A from matrix-variate normal distribution\n  A.posterior[,,s]      &lt;- matrix(mvtnorm::rmvnorm(1, mean=as.vector(A.bar), sigma=Sigma.posterior[,,s]%x%V.bar), ncol=N)\n  \n  ### Draw lambda from inverse gamma 2 distribution\n  s.posterior.lambda    &lt;- sum(diag(Sigma.posterior.inv%*%t(Y-X%*%A.posterior[,,s])%*%(Y-X%*%A.posterior[,,s]))) + s.prior.lambda\n  nu.posterior.lambda   &lt;- nrow(Y)*N + nu.prior.lambda\n  lambda   &lt;- s.posterior.lambda/rchisq(1, nu.posterior.lambda)\n  lambda.posterior[s]   &lt;- lambda\n  \n  ## Draw from the Structural Form\n  ### Draw B0\n  cholSigma.s        &lt;- chol(Sigma.posterior[,,s])\n  B0.posterior[,,s]  &lt;- solve(t(cholSigma.s))\n\n  ### Draw Bplus\n  B1.posterior[,,s]  &lt;- B0.posterior[,,s]%*%t(A.posterior[,,s])\n  }\n  \n# Identification via sign restrictions \n############################################################\n# Generate corresponding R matrix\nsign.restrictions &lt;- c(-1, 1, -1, 1, 0, 0)\nR &lt;- diag(sign.restrictions)\n  \n# Initialise arrays to store Q identified estimates\ni.vec &lt;- c()\nQ.store      &lt;- array(NA, c(N,N,S))\nB0.store     &lt;- array(NA, c(N,N,S))\nB1.store     &lt;- array(NA, c(N,K,S))\n  \nfor (s in 1:S){\n  B0.tilde      &lt;- B0.posterior[,,s]\n  B1.tilde      &lt;- B1.posterior[,,s]\n    \n  sign.restrictions.do.not.hold = TRUE\n  i=1\n  while (sign.restrictions.do.not.hold){\n    X           &lt;- matrix(rnorm(N*N), N, N)         \n    QR          &lt;- qr(X, tol=1e-10)\n    Q           &lt;- qr.Q(QR, complete=TRUE)\n    R           &lt;- qr.R(QR, complete=TRUE)\n    Q           &lt;- t(Q %*% diag(sign(diag(R))))\n    B0          &lt;- Q%*%B0.tilde                    \n    B1          &lt;- Q%*%B1.tilde                   \n    B0.inv      &lt;- solve(B0)      \n    check       &lt;- all(B0.inv[1,2]&lt;0, B0.inv[2,2]&gt;0, B0.inv[3,2]&lt;0, B0.inv[4,2]&gt;0)\n    \n    if (check){sign.restrictions.do.not.hold = FALSE}\n    i=i+1\n    }\n  \n  i.vec &lt;- c(i.vec, i) \n  Q.store[,,s]   &lt;- Q\n  B0.store[,,s]  &lt;- B0\n  B1.store[,,s]  &lt;- B1\n  }\n\n# Impulse response functions\n############################################################\n# Transform B0 matrices to B\n# Initialise arrays to store posterior draws\nB.posterior &lt;- array(NA, c(N,N,S))\n  \nfor (s in 1:S){\n  B.posterior[,,s]  &lt;- solve(B0.store[,,s])\n  }\n\n# Initialise arrays to store posterior draws\nIRF.posterior       &lt;- array(NA, c(N,N,h+1,S))\nIRF.inf.posterior   &lt;- array(NA, c(N,N,S))\nJ                   &lt;- cbind(diag(N), matrix(0,N,N*(p-1)))\n  \nfor (s in 1:S){\n  # Define A matrix in VAR(1) representation\n  A.bold                     &lt;- rbind(t(A.posterior[2:(1+N*p),,s]), cbind(diag(N*(p-1)), matrix(0,N*(p-1),N)))\n  IRF.inf.posterior[,,s]     &lt;- J%*%solve(diag(N*p)-A.bold)%*%t(J)%*%B.posterior[,,s]\n  A.bold.power               &lt;- A.bold\n  \n  for (i in 1:(h+1)){\n    if (i==1){\n      IRF.posterior[,,i,s]      &lt;- B.posterior[,,s]\n      } else {\n        IRF.posterior[,,i,s]    &lt;- J%*%A.bold.power%*%t(J)%*%B.posterior[,,s]\n        A.bold.power            &lt;- A.bold.power%*%A.bold\n      }\n    }\n  }\n\nlibrary(HDInterval)\n\n# Impulse response functions plots\n############################################################\nIRF.posterior.mps   &lt;- IRF.posterior[,2,,]\nIRFs.k1             &lt;- apply(IRF.posterior.mps,1:2,median)\nIRFs.inf.k1         &lt;- apply(IRF.posterior.mps,1,mean)\nrownames(IRFs.k1)   &lt;- colnames(variables)\n\nIRFs.k1.hdi    &lt;- apply(IRF.posterior.mps, 1:2, hdi, credMass=0.68)\nhh             &lt;- 1:(h+1)\n\npar(mfrow=c(3, 2), mar=c(3, 3, 2, 2), cex.axis=1.5, cex.lab=1.5)\nfor (n in 1:N){\n  ylims=range(IRFs.k1[n,hh], IRFs.k1.hdi[,n,1:(h+1)], 0)\n  plot(hh,IRFs.k1[n,hh], type=\"l\", ylim=ylims, axes=FALSE, xlab=\"\", main=rownames(IRFs.k1)[n])\n  if (n==5){\n    axis(1, c(1,5,9,13,17,21), c(\"0\",\"1yr\",\"2yr\",\"3yr\",\"4yr\",\"5yr\"))\n    } else {\n      axis(1, c(1,5,9,13,17,21), c(\"0\",\"1yr\",\"2yr\",\"3yr\",\"4yr\",\"5yr\"))\n      }\n  axis(2, c(ylims[1], 0, ylims[2]), round(c(ylims[1], 0, ylims[2]), 3))\n  polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh], IRFs.k1.hdi[2,n,(h+1):1]), col=mcxs2.shade1, border=mcxs2.shade1)\n  abline(h=0)\n  lines(hh, IRFs.k1[n,hh], lwd=2, col=\"darkblue\")\n  }"
  },
  {
    "objectID": "index.html#bayesian-svar-model-with-common-stochastic-volatility-1",
    "href": "index.html#bayesian-svar-model-with-common-stochastic-volatility-1",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "5.3 Bayesian SVAR Model with Common Stochastic Volatility",
    "text": "5.3 Bayesian SVAR Model with Common Stochastic Volatility"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "The Effects of Monetary Policy Shocks on Stock Price Volatility: Evidence from the Australian Economy",
    "section": "References",
    "text": "References"
  }
]